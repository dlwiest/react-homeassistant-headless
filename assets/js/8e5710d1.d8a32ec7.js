"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6980],{8453:(n,t,e)=>{e.d(t,{R:()=>r,x:()=>l});var i=e(6540);const s={},o=i.createContext(s);function r(n){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function l(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(o.Provider,{value:t},n.children)}},9586:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"multiple-entities","title":"Working with Multiple Entities","description":"When building dashboards or complex interfaces, you often need to work with multiple entities at once. hass-react provides the useEntityGroup hook to efficiently manage collections of entities.","source":"@site/docs/multiple-entities.md","sourceDirName":".","slug":"/multiple-entities","permalink":"/docs/multiple-entities","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/multiple-entities.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Todo","permalink":"/docs/entities/todo"},"next":{"title":"Error Handling & Connection Status","permalink":"/docs/error-handling"}}');var s=e(4848),o=e(8453);const r={},l="Working with Multiple Entities",a={},d=[{value:"useEntityGroup Hook",id:"useentitygroup-hook",level:2},{value:"Working with Mixed Entity Types",id:"working-with-mixed-entity-types",level:2},{value:"Dynamic Entity Lists",id:"dynamic-entity-lists",level:2},{value:"Combining with Individual Entity Hooks",id:"combining-with-individual-entity-hooks",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Raw Entity State Access",id:"raw-entity-state-access",level:2},{value:"Single Entity Pattern",id:"single-entity-pattern",level:2}];function c(n){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"working-with-multiple-entities",children:"Working with Multiple Entities"})}),"\n",(0,s.jsxs)(t.p,{children:["When building dashboards or complex interfaces, you often need to work with multiple entities at once. hass-react provides the ",(0,s.jsx)(t.code,{children:"useEntityGroup"})," hook to efficiently manage collections of entities."]}),"\n",(0,s.jsx)(t.h2,{id:"useentitygroup-hook",children:"useEntityGroup Hook"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"useEntityGroup"})," hook allows you to subscribe to multiple entities and receive updates when any of them change. It returns an array of raw ",(0,s.jsx)(t.code,{children:"EntityState"})," objects:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import { useEntityGroup } from 'hass-react';\n\nfunction RoomLights() {\n  // Track multiple light entities\n  const entities = useEntityGroup([\n    'light.living_room',\n    'light.kitchen',\n    'light.dining_room'\n  ]);\n\n  return (\n    <div>\n      {entities.map((entity) => (\n        <div key={entity.entity_id}>\n          <h3>{entity.attributes.friendly_name || entity.entity_id}</h3>\n          <p>State: {entity.state}</p>\n          <p>Last Updated: {new Date(entity.last_updated).toLocaleString()}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"working-with-mixed-entity-types",children:"Working with Mixed Entity Types"}),"\n",(0,s.jsx)(t.p,{children:"You can group different types of entities together:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function SecurityOverview() {\n  const securityEntities = useEntityGroup([\n    'lock.front_door',\n    'lock.back_door',\n    'binary_sensor.front_door',\n    'binary_sensor.motion_detector',\n    'alarm_control_panel.house'\n  ]);\n\n  const doors = securityEntities.filter(e => e.entity_id.startsWith('lock.'));\n  const sensors = securityEntities.filter(e => e.entity_id.startsWith('binary_sensor.'));\n  const alarm = securityEntities.find(e => e.entity_id.startsWith('alarm_control_panel.'));\n\n  return (\n    <div className=\"security-overview\">\n      <section>\n        <h3>Door Locks</h3>\n        {doors.map((door) => (\n          <div key={door.entity_id}>\n            {door.attributes.friendly_name}: {door.state}\n          </div>\n        ))}\n      </section>\n      \n      <section>\n        <h3>Security Sensors</h3>\n        {sensors.map((sensor) => (\n          <div key={sensor.entity_id}>\n            {sensor.attributes.friendly_name}: {sensor.state}\n          </div>\n        ))}\n      </section>\n      \n      {alarm && (\n        <section>\n          <h3>Alarm System</h3>\n          <div>Status: {alarm.state}</div>\n        </section>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"dynamic-entity-lists",children:"Dynamic Entity Lists"}),"\n",(0,s.jsx)(t.p,{children:"You can dynamically change which entities you're tracking:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function FloorControl() {\n  const [selectedFloor, setSelectedFloor] = useState('ground');\n  \n  const floorEntities = {\n    ground: ['light.living_room', 'light.kitchen', 'light.dining_room'],\n    upstairs: ['light.bedroom', 'light.bathroom', 'light.office']\n  };\n  \n  const entities = useEntityGroup(floorEntities[selectedFloor]);\n\n  return (\n    <div>\n      <nav>\n        <button \n          onClick={() => setSelectedFloor('ground')}\n          className={selectedFloor === 'ground' ? 'active' : ''}\n        >\n          Ground Floor\n        </button>\n        <button \n          onClick={() => setSelectedFloor('upstairs')}\n          className={selectedFloor === 'upstairs' ? 'active' : ''}\n        >\n          Upstairs\n        </button>\n      </nav>\n      \n      <div className=\"entity-grid\">\n        {entities.map((entity) => (\n          <LightCard key={entity.entity_id} entity={entity} />\n        ))}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"combining-with-individual-entity-hooks",children:"Combining with Individual Entity Hooks"}),"\n",(0,s.jsxs)(t.p,{children:["For entities that need control functionality, combine ",(0,s.jsx)(t.code,{children:"useEntityGroup"})," for overview data with individual hooks for controls:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function LightingDashboard() {\n  // Get overview of all lights\n  const allLights = useEntityGroup([\n    'light.living_room',\n    'light.kitchen', \n    'light.bedroom',\n    'light.bathroom'\n  ]);\n\n  // Individual hooks for lights that need controls\n  const livingRoom = useLight('light.living_room');\n  const kitchen = useLight('light.kitchen');\n\n  const totalLights = allLights.length;\n  const lightsOn = allLights.filter(light => light.state === 'on').length;\n\n  return (\n    <div>\n      <div className=\"summary\">\n        <h2>Lighting Overview</h2>\n        <p>{lightsOn} of {totalLights} lights are on</p>\n        \n        <button \n          onClick={() => {\n            allLights.forEach(light => {\n              // Would need individual hooks for each to control them\n              // This is just for display\n            });\n          }}\n          disabled={lightsOn === totalLights}\n        >\n          Turn All On\n        </button>\n      </div>\n\n      <div className=\"light-controls\">\n        <LightControl \n          name=\"Living Room\" \n          light={livingRoom} \n        />\n        <LightControl \n          name=\"Kitchen\" \n          light={kitchen} \n        />\n        \n        {/* Read-only displays for other lights */}\n        {allLights\n          .filter(light => !['light.living_room', 'light.kitchen'].includes(light.entity_id))\n          .map(light => (\n            <LightDisplay key={light.entity_id} entity={light} />\n          ))\n        }\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"useEntityGroup"})," is optimized for performance:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Efficient subscriptions"}),": Only subscribes to the entities you specify"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Automatic cleanup"}),": Unsubscribes when entities are removed from the list"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Minimal re-renders"}),": Only re-renders when the tracked entities actually change"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function OptimizedDashboard() {\n  const [showDetails, setShowDetails] = useState(false);\n  \n  // Always track core entities\n  const coreEntities = useEntityGroup([\n    'sensor.temperature',\n    'sensor.humidity',\n    'binary_sensor.motion'\n  ]);\n  \n  // Only track detailed entities when needed\n  const detailedEntities = useEntityGroup(\n    showDetails ? [\n      'sensor.pressure',\n      'sensor.light_level', \n      'sensor.air_quality',\n      'sensor.noise_level'\n    ] : []\n  );\n\n  return (\n    <div>\n      <div className=\"core-stats\">\n        {coreEntities.map(entity => (\n          <StatCard key={entity.entity_id} entity={entity} />\n        ))}\n      </div>\n      \n      <button onClick={() => setShowDetails(!showDetails)}>\n        {showDetails ? 'Hide' : 'Show'} Details\n      </button>\n      \n      {showDetails && (\n        <div className=\"detailed-stats\">\n          {detailedEntities.map(entity => (\n            <StatCard key={entity.entity_id} entity={entity} />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(t.p,{children:"Entities in the group might be unavailable or have errors:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function RobustEntityGroup() {\n  const entities = useEntityGroup([\n    'light.living_room',\n    'light.possibly_offline',\n    'sensor.temperature'\n  ]);\n\n  const availableEntities = entities.filter(entity => \n    entity.state !== 'unavailable' && entity.state !== 'unknown'\n  );\n  \n  const unavailableCount = entities.length - availableEntities.length;\n\n  return (\n    <div>\n      {unavailableCount > 0 && (\n        <div className=\"warning\">\n          {unavailableCount} entities are currently unavailable\n        </div>\n      )}\n      \n      {availableEntities.map(entity => (\n        <EntityCard key={entity.entity_id} entity={entity} />\n      ))}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"raw-entity-state-access",children:"Raw Entity State Access"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"useEntityGroup"})," returns raw ",(0,s.jsx)(t.code,{children:"EntityState"})," objects with the following structure:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"interface EntityState {\n  entity_id: string;\n  state: string;\n  attributes: Record<string, any>;\n  last_changed: string;\n  last_updated: string;\n  context: {\n    id: string;\n    parent_id: string | null;\n    user_id: string | null;\n  };\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"single-entity-pattern",children:"Single Entity Pattern"}),"\n",(0,s.jsxs)(t.p,{children:["You can also use ",(0,s.jsx)(t.code,{children:"useEntityGroup"})," with a single entity if you only need the raw state data:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function SimpleEntityDisplay() {\n  // Alternative to useLight when you only need to display state\n  const [temperatureEntity] = useEntityGroup(['sensor.temperature']);\n  \n  if (!temperatureEntity) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h3>{temperatureEntity.attributes.friendly_name}</h3>\n      <p>\n        {temperatureEntity.state}\n        {temperatureEntity.attributes.unit_of_measurement}\n      </p>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"useEntityGroup"})," hook is perfect for dashboards, overview screens, and any interface that needs to display or monitor multiple Home Assistant entities efficiently."]})]})}function h(n={}){const{wrapper:t}={...(0,o.R)(),...n.components};return t?(0,s.jsx)(t,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);